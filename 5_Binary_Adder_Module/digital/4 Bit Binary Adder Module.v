/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_D_FF_AS_Nbit
#(
    parameter Bits = 2,
    parameter Default = 0
)
(
   input Set,
   input [(Bits-1):0] D,
   input C,
   input Clr,
   output [(Bits-1):0] Q,
   output [(Bits-1):0] \~Q
);
    reg [(Bits-1):0] state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= {Bits{1'b1}};
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



// hex synchronous counter, async clear
module \74161  (
  input \~LD ,
  input \~CLR ,
  input CLK,
  input ENT,
  input ENP,
  input A,
  input B,
  input C,
  input D,
  input VCC,
  input GND,
  output RCO,
  output QA,
  output QB,
  output QC,
  output QD
);
  wire [3:0] s0;
  wire [3:0] s1;
  wire s2;
  wire s3;
  wire [3:0] s4;
  wire [3:0] s5;
  wire [3:0] s6;
  wire s7;
  assign s3 = (ENP & ENT);
  assign s5[0] = A;
  assign s5[1] = B;
  assign s5[2] = C;
  assign s5[3] = D;
  assign s7 = ~ \~CLR ;
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i0 (
    .sel( s3 ),
    .in_0( s0 ),
    .in_1( s1 ),
    .out( s4 )
  );
  assign RCO = (s2 & ENT);
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i1 (
    .sel( \~LD  ),
    .in_0( s5 ),
    .in_1( s4 ),
    .out( s6 )
  );
  DIG_D_FF_AS_Nbit #(
    .Bits(4),
    .Default(0)
  )
  DIG_D_FF_AS_Nbit_i2 (
    .Set( 1'b0 ),
    .D( s6 ),
    .C( CLK ),
    .Clr( s7 ),
    .Q( s0 )
  );
  DIG_Add #(
    .Bits(4)
  )
  DIG_Add_i3 (
    .a( s0 ),
    .b( 4'b1 ),
    .c_i( 1'b0 ),
    .s( s1 ),
    .c_o( s2 )
  );
  assign QA = s0[0];
  assign QB = s0[1];
  assign QC = s0[2];
  assign QD = s0[3];
endmodule

// 4-bit binary full adder, alternative pinning
module \74283  (
  input C0,
  input B1,
  input B2,
  input B3,
  input B4,
  input A1,
  input A2,
  input A3,
  input A4,
  input VCC,
  input GND,
  output S1,
  output S2,
  output S3,
  output S4,
  output C4
);
  wire [3:0] s0;
  wire [3:0] s5;
  wire [3:0] s6;
  assign s5[0] = B1;
  assign s5[1] = B2;
  assign s5[2] = B3;
  assign s5[3] = B4;
  assign s0[0] = A1;
  assign s0[1] = A2;
  assign s0[2] = A3;
  assign s0[3] = A4;
  DIG_Add #(
    .Bits(4)
  )
  DIG_Add_i0 (
    .a( s0 ),
    .b( s5 ),
    .c_i( C0 ),
    .s( s6 ),
    .c_o( C4 )
  );
  assign S1 = s6[0];
  assign S2 = s6[1];
  assign S3 = s6[2];
  assign S4 = s6[3];
endmodule

module \4_Bit_Binary_Adder_Module  (
  input Count_1,
  input Count_2,
  input Clear,
  output A0,
  output A1,
  output A2,
  output A3,
  output B0,
  output B1,
  output B2,
  output B3,
  output S0,
  output S1,
  output S2,
  output S3,
  output S4
);
  wire A3_temp;
  wire A2_temp;
  wire A1_temp;
  wire A0_temp;
  wire B3_temp;
  wire B2_temp;
  wire B1_temp;
  wire B0_temp;
  // Counter
  \74161  \74161_i0 (
    .\~CLR ( Clear ),
    .CLK( Count_1 ),
    .A( 1'b0 ),
    .B( 1'b0 ),
    .C( 1'b0 ),
    .D( 1'b0 ),
    .ENP( 1'b1 ),
    .GND( 1'b0 ),
    .\~LD ( 1'b1 ),
    .ENT( 1'b1 ),
    .VCC( 1'b1 ),
    .QD( A3_temp ),
    .QC( A2_temp ),
    .QB( A1_temp ),
    .QA( A0_temp )
  );
  // Counter
  \74161  \74161_i1 (
    .\~CLR ( Clear ),
    .CLK( Count_2 ),
    .A( 1'b0 ),
    .B( 1'b0 ),
    .C( 1'b0 ),
    .D( 1'b0 ),
    .ENP( 1'b1 ),
    .GND( 1'b0 ),
    .\~LD ( 1'b1 ),
    .ENT( 1'b1 ),
    .VCC( 1'b1 ),
    .QD( B3_temp ),
    .QC( B2_temp ),
    .QB( B1_temp ),
    .QA( B0_temp )
  );
  \74283  \74283_i2 (
    .B2( B1_temp ),
    .A2( A1_temp ),
    .A1( A0_temp ),
    .B1( B0_temp ),
    .C0( 1'b0 ),
    .GND( 1'b0 ),
    .B4( B3_temp ),
    .A4( A3_temp ),
    .A3( A2_temp ),
    .B3( B2_temp ),
    .VCC( 1'b1 ),
    .S2( S1 ),
    .S1( S0 ),
    .C4( S4 ),
    .S4( S3 ),
    .S3( S2 )
  );
  assign A0 = A0_temp;
  assign A1 = A1_temp;
  assign A2 = A2_temp;
  assign A3 = A3_temp;
  assign B0 = B0_temp;
  assign B1 = B1_temp;
  assign B2 = B2_temp;
  assign B3 = B3_temp;
endmodule
